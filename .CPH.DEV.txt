
In the case of a template function,
could the returned signature be a temple non-union signature with mapping, but no instantiations?
So instantiations could be created "on-demand"?
That still wouldn't handle the general case of a union of signatures.

-----------------------------------------------------------

Pass generic overloads to resolveCall in its generic form and
process each parameter at the point of matching.

The current defacto behavior is to combine parameters rather than testing seperately.
Combined means
callType<T>.parameter[i] @ T= union of constraints
or
callType<T>.parameter[i] @ T= intersection of constraints
which one is right?

Status quo is taking the union for array function parameters when all types are either ReadonlyArray or Array,
but not mixed.
When they are mixed, the defacto behavior is try to combine the signatures,
which fails, and may cause an error.

However, in the mixed case, the signature of the `filter`'s `predicate`'s first (`value`) and second (`number`) parameters
are the same for both ReadonlyArray and Array. It is only the third parameter (`array`) that varies - `readonly T[]` vs `T[]`.

So if `array` is not `used`, there should be no need to fail.

ReadonlyArray
```
    filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S, thisArg?: any): S[];
    filter(predicate: BooleanConverter, thisArg?: any): (T extends false | 0 | "" | null | undefined | 0n ? never : T)[];
    filter(predicate: (value: T, index: number, array: readonly T[]) => unknown, thisArg?: any): T[];
```

Array
```
    filter<S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];
    filter(predicate: BooleanConverter, thisArg?: any): (T extends false | 0 | "" | null | undefined | 0n ? never : T)[];
    filter(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T[];
```

I propose this algorithm where T is a union type:

passing: {overload, subtype}[] = []
failing: {overload}[] = []
type AssignableResult = "never" | "weak" | "strong"
declare psuedoAssignable (arg: Type, t: Type): AssignableResult
For each generic overload<T0>
    let T = T0
    let stronglyMatched = true;
    overload:
    For each parameter param<T>[i]
        For each type t in range of T
            r = psuedoAssignable(arg[i], param<T@t>[i]));
            if r==="never"
                T = T-t;
            if T is never break overload;
            if r!=="strong"
                stronglyMatched = false;
    if T is never
        failing.push(overload<T0>)
    else passing.push(overload<T0@T>, T)
    if stronglyMatched break; //

As long as there is at least one overload passing (not necessarily a strong match)
then there is no error.

Inside resolveCallExpressionV2

1. Determine if type is overloads (narrow our initial also to: and generic, and array).
   It doesn't have to be that all generic variants share the same target.
   If not goto V1

2. To be able to get through to chooseOverload, we have to create a viable



