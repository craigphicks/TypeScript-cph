The strategy of branching Node/Symbol links table is not able to
completely insulate the changes during branching.  Somehow there is leakage,
probably related to caching.

For example in `tests/cases/compiler/_arrayFrom.ts` these orders of lines are ok

ok:
```
Array.from(inputB, ({ b }): A => ({ a: b }));
Array.from(inputA.values());
```

ok:
```
Array.from(inputB, ({ b }): A => ({ a: b }));
Array.from(inputA.values());
Array.from(inputB, ({ b }): A => ({ a: b }));
```


but this order is causes `reseolveCallExpressionV2` to error, probably because some chached results
cause a wrong short cut to be taken.

ng:
```
Array.from(inputA.values());
Array.from(inputB, ({ b }): A => ({ a: b }));
```

So I think it is better to use types and a [symbol table, type symbol table]
to search the solution space


overloads:
    [0] from<T>(iterable: Iterable<T> | ArrayLike<T>): T[];
    [1] from<T, U>(iterable: Iterable<T{0}> | ArrayLike<T{1}>, mapfn: (v: T{2}, k: number) => U, thisArg?: any): U[];

type parameters:
    typeof this: unnknown[]
    T: unknown
    U: unknown

function arguments
    0: B[]
    1: ({b})=>{a:b}

(1)
    overload[0]: too many arguments
    overload[1]:
      isAcceptable(B[],Iterable<any>): no
      isAcceptable(B[],ArrayLike<any>): yes
      bind(T{1}, B)
      because it T{1} was inferred from an array all T{n} bind to B
      isAcceptable({b}, T as B): yes
      //bind(T{2}, {b:any}):
      bind(U,{a:string})




      mapfn => bind(T{2}, {b})
    mapfn => bind(U{0}, A)


search for
function inst.*MappedType

    function instantiateMappedType
    function instantiateMappedArrayType
    function instantiateMappedTypeArray(type: MappedType
    etc


function instantiateAnonymousType(type,...)
type.symbol.escapedName==="filter"

function getObjectTypeInstantiation

typeToString(target)
'{
<S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[];
(predicate: BooleanConverter, thisArg?: any): (T extends false | "" | 0 | 0n ? never : T)[];
(predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T[];
}'[95]
(same as result type.target)


    const newMapper = createTypeMapper(typeParameters, typeArguments);


typeToString(typeParameters[0])
'T'[67]
typeToString(typeParameters[1])
'this'[68]

typeToString(typeArguments[0])
'Fizz'[85]
typeToString(typeArguments[1])
'Fizz[]'[87]

    instantiateAnonymousType(target, newMapper, newAliasSymbol, newAliasTypeArguments);

checkPropertyAccessExpressionOrQualifiedName
node.id===33


createUnionOrIntersectionProperty(containingType: UnionOrIntersectionType, name: __String, skipObjectFunctionPropertyAugment?: boolean): Symbol | undefined
e.g. containingType === "Fizz[]"

This will work ----

typeToString(getTypeOfSymbol(getPropertyOfType(createArrayType(anyType),"filter")))
'{
    <S extends any>(predicate: (value: any, index: number, array: any[]) => value is S, thisArg?: any): S[];
    (predicate: BooleanConverter, thisArg?: any): any[];
    (predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): any[];
}'
Great!

But it's not the most general way which would be to map the target function, as was somewhere already done for Fizz and Buzz.

apparentType.types[0].target.instantiations.forEach((v,k)=>console.log(typeToString(v)))
{ <S extends T>(predicate: (value: T, index: number, array: T[]) => value is S, thisArg?: any): S[]; (predicate: BooleanConverter, thisArg?: any): (T extends false | "" | 0 | 0n ? never : T)[]; (predicate: (value: T, index: number, array: T[]) => unknown, thisArg?: any): T[]; }
repl:1
{ <S extends Fizz>(predicate: (value: Fizz, index: number, array: Fizz[]) => value is S, thisArg?: any): S[]; (predicate: BooleanConverter, thisArg?: any): Fizz[]; (predicate: (value: Fizz, index: number, array: Fizz[]) => unknown, thisArg?: any): Fizz[]; }
repl:1
{ <S extends Buzz>(predicate: (value: Buzz, index: number, array: Buzz[]) => value is S, thisArg?: any): S[]; (predicate: BooleanConverter, thisArg?: any): Buzz[]; (predicate: (value: Buzz, index: number, array: Buzz[]) => unknown, thisArg?: any): Buzz[]; }

Then checking that the function is an array property and creating `any[]` would not be necessary.

Resolve call does not return the narrowed  candidates in
This looks helpful because
`function getOrCreateTypeFromSignature(signature: Signature): ObjectType`

-------------------------------------------------------------------

- There are still 317 error messages left - this would take a long time and leave the source in a vastly changed state.
Going to split this into a branch (origin-main-booleanArrayFilter-linkxet) and go back to the last working
version.
From there
- I think there is a possibility that simply making transient symbols cacheable, and implementing leveled chaching,
would be enough to solve this problem.
- But in order to implement leveled caching efficiently it is necessary to know which links have been altered.
- The transient symbols all one of thes way to access their links:
- getSymbolLinks(symbol)
- symbol.links;       (read)
- symbol.links = ...; (write)
- symbol.links.XXX;        (read)
- symbol.links.XXX = ...;  (write)
- symbol.links.XXX.YYY...;       (read)
- symbol.links.XXX.YYY... = ...; (write) (will not be informed of write change)
Actually all cases may result in failure to inform of change because a read element can then be written,
so we will consider all such cases to concwptually belong to the last case. But those are just the cases where caching might fail anyway, because the links.XXX inner values have been altered. First priority strategy would be to add on-write caching while assuming that such cases do NOT exist, and to do it in way the requires as few changes to the existing code as possible. Reviewing the code with regexp, cases of `links.XXX.YYY` at least do not jump out, so it is reasonable to try assuming all write changes can be detected.
- SymbolLinks.XXX will be proxied to detect writes.
- Symbol.links will be proxied to detect writes.
- We don't actually need to cache each SymbolLinks property independently because in general it is not expensive to create a new links object if even one property has been changed.  That makes multi-level caching easier to implement.
- We *could* make `links.XXX;` return a readonly value by using `get p(): Readonly<...>`, which would catch shallow access write notification failures, as that code must be changed to enable write detection;

```
interface X {x: number, y: {z: number}};
type Links1 = {
    p: X
};
type Links2 = {
    get p(): Readonly<X>;
    set p(x:X);
};

declare let links1: Readonly<Links1>;
links1.p.x;
links1.p.x = 1; // not caught
let p1 = links1.p;
p1.x = 2; // not caught

declare let links2: Links2;
links2.p.x;
links2.p.x = 1; // error, caught
let p2 = links2.p;
p2.x = 2; // error, caught
p2.y.z = 2; // no error, not caught

// Rewrite the erroring code as follows if semantically allowed in the program.
let p3 = { ... links2.p } // or new(links2.p)
p3.x = 2; // no error, ok
links2.p = p3; // write notification.
// but if somewhere else was crititically referencing the links2.p object directly that would
// critically change the program logic - a bug.
```
Therefore, step 1 does NOT include making read accesses Readonly.  Only if step 1 alone does not succeed,
then step 2 would add in the Readonly on get(), and try making the necessary changes. Which might be a rats nest.


---------------------------------------------------------

In the case of a template function,
could the returned signature be a temple non-union signature with mapping, but no instantiations?
So instantiations could be created "on-demand"?
That still wouldn't handle the general case of a union of signatures.

