=== tests/cases/conformance/_cax/_cax-ez3.ts ===
declare type Foo = { 
>Foo : { foo(x?: number): number[]; foo(x?: string, y?: string): string[]; }

    foo(x?:number):number[] 
>foo : { (x?: number): number[]; (x?: string | undefined, y?: string | undefined): string[]; }
>x : number | undefined

    foo(x?:string,y?:string):string[] 
>foo : { (x?: number | undefined): number[]; (x?: string, y?: string): string[]; }
>x : string | undefined
>y : string | undefined

};
declare type Boo = { 
>Boo : { foo(x?: bigint): bigint[]; }

    foo(x?:bigint):bigint[]  
>foo : (x?: bigint) => bigint[]
>x : bigint | undefined

};
declare const obj: Readonly<Foo> | Readonly<Boo> | undefined;
>obj : Readonly<Foo> | Readonly<Boo> | undefined

// declare const okobj: Readonly<Foo> | Readonly<Boo>;
const isFoo = obj?.foo();
>isFoo : number[] | bigint[] | undefined
>obj?.foo() : number[] | bigint[] | undefined
>obj?.foo : { (x?: number | undefined): number[]; (x?: string | undefined, y?: string | undefined): string[]; } | ((x?: bigint | undefined) => bigint[]) | undefined
>obj : Readonly<Foo> | Readonly<Boo> | undefined
>foo : { (x?: number | undefined): number[]; (x?: string | undefined, y?: string | undefined): string[]; } | ((x?: bigint | undefined) => bigint[]) | undefined

//let x: Readonly<Foo> | Readonly<Boo> | undefined;
if (isFoo) {
>isFoo : number[] | string[] | bigint[] | undefined

    isFoo;
>isFoo : number[] | string[] | bigint[]

    let x = obj; // x should be Readonly<Foo> | Readonly<Boo>
>x : Readonly<Foo> | Readonly<Boo>
>obj : Readonly<Foo> | Readonly<Boo>

    let y = x.foo; // should be no error
>y : { (x?: number | undefined): number[]; (x?: string | undefined, y?: string | undefined): string[]; } | ((x?: bigint | undefined) => bigint[])
>x.foo : { (x?: number | undefined): number[]; (x?: string | undefined, y?: string | undefined): string[]; } | ((x?: bigint | undefined) => bigint[])
>x : Readonly<Foo> | Readonly<Boo>
>foo : { (x?: number | undefined): number[]; (x?: string | undefined, y?: string | undefined): string[]; } | ((x?: bigint | undefined) => bigint[])

    let z = y(); // z should be number[] | string[] | bigint[] - it is not because obtained via checker.ts,resolveCallExpression
>z : number[] | bigint[]
>y() : number[] | bigint[]
>y : { (x?: number | undefined): number[]; (x?: string | undefined, y?: string | undefined): string[]; } | ((x?: bigint | undefined) => bigint[])

    console.log(z); // again z should be number[] | string[] | bigint[] - now it is because it is obtained via getFlowTypeOfReference
>console.log(z) : void
>console.log : (...data: any[]) => void
>console : Console
>log : (...data: any[]) => void
>z : number[] | string[] | bigint[]
} 
isFoo;
>isFoo : number[] | string[] | bigint[] | undefined

