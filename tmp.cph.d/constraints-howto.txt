






declare const c1: true|false;
declare const c2: true|false;
if (c1 && c2){
    c1;
    c2;
}
else if (c1){
    c1;
    c2;
}
else if (c2){
    c1;
    c2;
}
else {
    c1;
    c2;
}

    symtab []
if (c1 && c2)

    
    true branch of (c1 && c2): 
    type: true
    symtab [c1:true, c2:true]
    constraint: and(c1:true,c2:true)

    false branch of (c1 && c2): 
    type: false
    symtab:[]
    constraint: !and(c1:true,c2:true)

{
    c1: symbol table mono type => true
    c2: symbol table mono type => true

    can delete true branch of (c1 && c2)
}    

else if (c1) 

    true: 
    type: true
    symtab [c1:true]
    constraint is and( constraint((c1)), constraint false branch of (c1&&c2))
    constraint: and(c1:true, !and(c1:true,c2:true)) => and(c1:true, !and(c2:true)) => and(c1:true,c2:!true)

    false: 
    type: false
    constraint is !and( constraint((c1)), constraint false branch of (c1&&c2))
    constraint: and(c1:!true, !and(c1:true,c2:true)) => and(c1:!true, !and(never, c2:true)) => c1:!true
    symtab []

    can delete false branch of (c1 && c2)
    can delete whole cbe of (c1 && c2)

{
    c1: symbol table mono type => true
    c2: from constraint => c2:!true

    can delete true branch of (c1)
}

else if (c2) 

    true: 
    type: true
    symtab [c2:true]
    constraint is and( constraint((c2)), constraint false branch of (c1)) 
    Note: constraint false branch of (c1 && c2 ) not directly referenced, it is already merged into constraint true branch of (c1) 
    constraint: and(c2:true, c1:!true)

    false: 
    type: false
    constraint is and( !constraint((c2)), constraint false branch of (c1)) Note: constraint false branch of (c1 && c2 ) not directly referenced 
    constraint: and(c2:!true, c1:!true))
    symtab []

    can delete false branch of (c1)
    can delete whole cbe of (c1)

{
    c1: from constraint -> c1:!true
    c2: symbol table mono type => true
    
    can delete true branch of (c2)
}

else 

{
    c1: from constraint -> c1:!true
    c2: from constraint -> c2:!true

    can delete false branch of (c2)
    can delete whole cbe of (c2)

}








