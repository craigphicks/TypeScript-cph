//// [tests/cases/compiler/-test3/-57087-104.ts] ////

=== -57087-104.ts ===
interface C {
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))

  (x:1):"1";
>x : Symbol(x, Decl(-57087-104.ts, 1, 3))

  (x:2):"20";
>x : Symbol(x, Decl(-57087-104.ts, 2, 3))

  (x:number):number | "1" | "20";
>x : Symbol(x, Decl(-57087-104.ts, 3, 3))

};
interface B {
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))

  (x:2):"2"
>x : Symbol(x, Decl(-57087-104.ts, 6, 3))

  (x:3):"30"
>x : Symbol(x, Decl(-57087-104.ts, 7, 3))

  (x:number):number | "2" | "30";
>x : Symbol(x, Decl(-57087-104.ts, 8, 3))

};
interface A {
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))

  (x:3):"3"
>x : Symbol(x, Decl(-57087-104.ts, 11, 3))

  (x:1):"10"
>x : Symbol(x, Decl(-57087-104.ts, 12, 3))

  (x:number):number | "3" | "10";
>x : Symbol(x, Decl(-57087-104.ts, 13, 3))

};

type W = (A & B & C)|(A & C & B)|(B & A & C)|(B & C & A)|(C & A & B)|(C & B & A);
>W : Symbol(W, Decl(-57087-104.ts, 14, 2))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))

/*
* Scenario:
* (1) Overloads: Usng fully expanded domain support for C & B & A, so that all errors are detected at compile time
* (2) Implementation:
*     - Note extra lines added to make the function signature compatible with the implementation
* Disadvatage: More verbosity in number of overloads and in implementation.
* Number of overloads could impact compile time, and makes life harder for downstream users of the function
*/
function foo2(x:1):"1";
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>x : Symbol(x, Decl(-57087-104.ts, 26, 14))

function foo2(x:2):"20";
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>x : Symbol(x, Decl(-57087-104.ts, 27, 14))

function foo2(x:number):number;
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>x : Symbol(x, Decl(-57087-104.ts, 28, 14))

function foo2(x:2):"2"
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>x : Symbol(x, Decl(-57087-104.ts, 29, 14))

function foo2(x:3):"30"
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>x : Symbol(x, Decl(-57087-104.ts, 30, 14))

function foo2(x:number):number;
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>x : Symbol(x, Decl(-57087-104.ts, 31, 14))

function foo2(x:3):"3"
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>x : Symbol(x, Decl(-57087-104.ts, 32, 14))

function foo2(x:1):"10"
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>x : Symbol(x, Decl(-57087-104.ts, 33, 14))

function foo2(x:number):number;
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>x : Symbol(x, Decl(-57087-104.ts, 34, 14))

function foo2(x:number){
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>x : Symbol(x, Decl(-57087-104.ts, 35, 14))

  if (x===1) return "1";
>x : Symbol(x, Decl(-57087-104.ts, 35, 14))

  if (x===2) return "2";
>x : Symbol(x, Decl(-57087-104.ts, 35, 14))

  if (x===3) return "3";
>x : Symbol(x, Decl(-57087-104.ts, 35, 14))

  // (*) These nonsense unused extra lines need to be added to make the function signature compatible with the implementation
  if (x===1) return "10";
>x : Symbol(x, Decl(-57087-104.ts, 35, 14))

  if (x===2) return "20";
>x : Symbol(x, Decl(-57087-104.ts, 35, 14))

  if (x===3) return "30";
>x : Symbol(x, Decl(-57087-104.ts, 35, 14))

  return x;
>x : Symbol(x, Decl(-57087-104.ts, 35, 14))
}

foo2 satisfies A & B & C; // should satisfy
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))

foo2 satisfies A & C & B; // should satisfy
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))

foo2 satisfies B & A & C; // should satisfy
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))

foo2 satisfies B & C & A; // should satisfy
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))

foo2 satisfies C & A & B; // should satisfy
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))

foo2 satisfies C & B & A; // should satisfy
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))

foo2 satisfies W; // should satisfy
>foo2 : Symbol(foo2, Decl(-57087-104.ts, 16, 81), Decl(-57087-104.ts, 26, 23), Decl(-57087-104.ts, 27, 24), Decl(-57087-104.ts, 28, 31), Decl(-57087-104.ts, 29, 22) ... and 5 more)
>W : Symbol(W, Decl(-57087-104.ts, 14, 2))


/*
* Scenario: Select some overloads from the orignal set of overloads.
* Advantages:
*     - Less verbosity in number of overloads
*     - Less verbosity in implementation
* Number of overloads could impact compile time, and makes life harder for downstream users of the function
*/
function foo1(x:1):"1";
>foo1 : Symbol(foo1, Decl(-57087-104.ts, 52, 17), Decl(-57087-104.ts, 62, 23), Decl(-57087-104.ts, 63, 23), Decl(-57087-104.ts, 64, 23), Decl(-57087-104.ts, 65, 31))
>x : Symbol(x, Decl(-57087-104.ts, 62, 14))

function foo1(x:2):"2";
>foo1 : Symbol(foo1, Decl(-57087-104.ts, 52, 17), Decl(-57087-104.ts, 62, 23), Decl(-57087-104.ts, 63, 23), Decl(-57087-104.ts, 64, 23), Decl(-57087-104.ts, 65, 31))
>x : Symbol(x, Decl(-57087-104.ts, 63, 14))

function foo1(x:3):"3";
>foo1 : Symbol(foo1, Decl(-57087-104.ts, 52, 17), Decl(-57087-104.ts, 62, 23), Decl(-57087-104.ts, 63, 23), Decl(-57087-104.ts, 64, 23), Decl(-57087-104.ts, 65, 31))
>x : Symbol(x, Decl(-57087-104.ts, 64, 14))

function foo1(x:number):number;
>foo1 : Symbol(foo1, Decl(-57087-104.ts, 52, 17), Decl(-57087-104.ts, 62, 23), Decl(-57087-104.ts, 63, 23), Decl(-57087-104.ts, 64, 23), Decl(-57087-104.ts, 65, 31))
>x : Symbol(x, Decl(-57087-104.ts, 65, 14))

function foo1(x:number){
>foo1 : Symbol(foo1, Decl(-57087-104.ts, 52, 17), Decl(-57087-104.ts, 62, 23), Decl(-57087-104.ts, 63, 23), Decl(-57087-104.ts, 64, 23), Decl(-57087-104.ts, 65, 31))
>x : Symbol(x, Decl(-57087-104.ts, 66, 14))

  if (x===1) return "1";
>x : Symbol(x, Decl(-57087-104.ts, 66, 14))

  if (x===2) return "2";
>x : Symbol(x, Decl(-57087-104.ts, 66, 14))

  if (x===3) return "3";
>x : Symbol(x, Decl(-57087-104.ts, 66, 14))

  return x;
>x : Symbol(x, Decl(-57087-104.ts, 66, 14))
}

// The `&`-intersection operator result should be independent of the order of it's operands.
foo1 satisfies A & B & C; // should not error
>foo1 : Symbol(foo1, Decl(-57087-104.ts, 52, 17), Decl(-57087-104.ts, 62, 23), Decl(-57087-104.ts, 63, 23), Decl(-57087-104.ts, 64, 23), Decl(-57087-104.ts, 65, 31))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))

foo1 satisfies A & C & B; // should not error
>foo1 : Symbol(foo1, Decl(-57087-104.ts, 52, 17), Decl(-57087-104.ts, 62, 23), Decl(-57087-104.ts, 63, 23), Decl(-57087-104.ts, 64, 23), Decl(-57087-104.ts, 65, 31))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))

foo1 satisfies B & A & C; // should not error
>foo1 : Symbol(foo1, Decl(-57087-104.ts, 52, 17), Decl(-57087-104.ts, 62, 23), Decl(-57087-104.ts, 63, 23), Decl(-57087-104.ts, 64, 23), Decl(-57087-104.ts, 65, 31))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))

foo1 satisfies B & C & A; // should not error
>foo1 : Symbol(foo1, Decl(-57087-104.ts, 52, 17), Decl(-57087-104.ts, 62, 23), Decl(-57087-104.ts, 63, 23), Decl(-57087-104.ts, 64, 23), Decl(-57087-104.ts, 65, 31))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))

foo1 satisfies C & A & B; // should not error
>foo1 : Symbol(foo1, Decl(-57087-104.ts, 52, 17), Decl(-57087-104.ts, 62, 23), Decl(-57087-104.ts, 63, 23), Decl(-57087-104.ts, 64, 23), Decl(-57087-104.ts, 65, 31))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))

foo1 satisfies C & B & A; // should not error
>foo1 : Symbol(foo1, Decl(-57087-104.ts, 52, 17), Decl(-57087-104.ts, 62, 23), Decl(-57087-104.ts, 63, 23), Decl(-57087-104.ts, 64, 23), Decl(-57087-104.ts, 65, 31))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))

foo1 satisfies W; // should not error
>foo1 : Symbol(foo1, Decl(-57087-104.ts, 52, 17), Decl(-57087-104.ts, 62, 23), Decl(-57087-104.ts, 63, 23), Decl(-57087-104.ts, 64, 23), Decl(-57087-104.ts, 65, 31))
>W : Symbol(W, Decl(-57087-104.ts, 14, 2))

/*
*/

//function foo3(x:1):"1"; //  Omitted domain support should cause satisfies error
function foo3(x:2):"2";
>foo3 : Symbol(foo3, Decl(-57087-104.ts, 80, 17), Decl(-57087-104.ts, 86, 23), Decl(-57087-104.ts, 87, 23), Decl(-57087-104.ts, 88, 31))
>x : Symbol(x, Decl(-57087-104.ts, 86, 14))

function foo3(x:3):"3";
>foo3 : Symbol(foo3, Decl(-57087-104.ts, 80, 17), Decl(-57087-104.ts, 86, 23), Decl(-57087-104.ts, 87, 23), Decl(-57087-104.ts, 88, 31))
>x : Symbol(x, Decl(-57087-104.ts, 87, 14))

function foo3(x:number):number;
>foo3 : Symbol(foo3, Decl(-57087-104.ts, 80, 17), Decl(-57087-104.ts, 86, 23), Decl(-57087-104.ts, 87, 23), Decl(-57087-104.ts, 88, 31))
>x : Symbol(x, Decl(-57087-104.ts, 88, 14))

function foo3(x:number): number | "1" | "2" | "3"{
>foo3 : Symbol(foo3, Decl(-57087-104.ts, 80, 17), Decl(-57087-104.ts, 86, 23), Decl(-57087-104.ts, 87, 23), Decl(-57087-104.ts, 88, 31))
>x : Symbol(x, Decl(-57087-104.ts, 89, 14))

  //if (x===1) return "1";
  if (x===2) return "2";
>x : Symbol(x, Decl(-57087-104.ts, 89, 14))

  if (x===3) return "3";
>x : Symbol(x, Decl(-57087-104.ts, 89, 14))

  return x;
>x : Symbol(x, Decl(-57087-104.ts, 89, 14))

  // In this case, a final throw "unexpected error" would never be reached anyway.
  // if (typeof x === "number") return x; // pointless
  // throw "unexpected error";
}

foo3 satisfies A & B & C; // should be error
>foo3 : Symbol(foo3, Decl(-57087-104.ts, 80, 17), Decl(-57087-104.ts, 86, 23), Decl(-57087-104.ts, 87, 23), Decl(-57087-104.ts, 88, 31))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))

foo3 satisfies A & C & B; // should be error
>foo3 : Symbol(foo3, Decl(-57087-104.ts, 80, 17), Decl(-57087-104.ts, 86, 23), Decl(-57087-104.ts, 87, 23), Decl(-57087-104.ts, 88, 31))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))

foo3 satisfies B & A & C; // should be error
>foo3 : Symbol(foo3, Decl(-57087-104.ts, 80, 17), Decl(-57087-104.ts, 86, 23), Decl(-57087-104.ts, 87, 23), Decl(-57087-104.ts, 88, 31))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))

foo3 satisfies B & C & A; // should be error
>foo3 : Symbol(foo3, Decl(-57087-104.ts, 80, 17), Decl(-57087-104.ts, 86, 23), Decl(-57087-104.ts, 87, 23), Decl(-57087-104.ts, 88, 31))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))

foo3 satisfies C & A & B; // should be error
>foo3 : Symbol(foo3, Decl(-57087-104.ts, 80, 17), Decl(-57087-104.ts, 86, 23), Decl(-57087-104.ts, 87, 23), Decl(-57087-104.ts, 88, 31))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))

foo3 satisfies C & B & A; // should be error
>foo3 : Symbol(foo3, Decl(-57087-104.ts, 80, 17), Decl(-57087-104.ts, 86, 23), Decl(-57087-104.ts, 87, 23), Decl(-57087-104.ts, 88, 31))
>C : Symbol(C, Decl(-57087-104.ts, 0, 0))
>B : Symbol(B, Decl(-57087-104.ts, 4, 2))
>A : Symbol(A, Decl(-57087-104.ts, 9, 2))


foo3 satisfies W; // should be error
>foo3 : Symbol(foo3, Decl(-57087-104.ts, 80, 17), Decl(-57087-104.ts, 86, 23), Decl(-57087-104.ts, 87, 23), Decl(-57087-104.ts, 88, 31))
>W : Symbol(W, Decl(-57087-104.ts, 14, 2))


