//// [tests/cases/compiler/-test3/-57087-105.ts] ////

=== -57087-105.ts ===
type A = { a: string };
>A : { a: string; }
>a : string

type B = { b: 1 };
>B : { b: 1; }
>b : 1

type C = { c: number };
>C : { c: number; }
>c : number


interface X1 {
    f(x:A):string
>f : { (x: A): string; (x: B): 1; }
>x : A

    f(x:B):1
>f : { (x: A): string; (x: B): 1; }
>x : B

    g(f: X1["f"],arg:A|B):()=>ReturnType<X1["f"]>
>g : (f: X1["f"], arg: A | B) => () => ReturnType<X1["f"]>
>f : { (x: A): string; (x: B): 1; }
>arg : A | B
}
interface X2 {
    f(x:C):number
>f : { (x: C): number; (x: B): "1"; }
>x : C

    f(x:B):"1";
>f : { (x: C): number; (x: B): "1"; }
>x : B

    g(f: X2["f"],arg:C|B):()=>ReturnType<X2["f"]>
>g : (f: X2["f"], arg: C | B) => () => ReturnType<X2["f"]>
>f : { (x: C): number; (x: B): "1"; }
>arg : B | C
}

declare const x1: X1;
>x1 : X1

declare const arg1: A|B;
>arg1 : A | B

x1.g(x1.f,arg1); // should be no error
>x1.g(x1.f,arg1) : () => 1
>x1.g : (f: { (x: A): string; (x: B): 1; }, arg: A | B) => () => 1
>x1 : X1
>g : (f: { (x: A): string; (x: B): 1; }, arg: A | B) => () => 1
>x1.f : { (x: A): string; (x: B): 1; }
>x1 : X1
>f : { (x: A): string; (x: B): 1; }
>arg1 : A | B

declare const x2: X2;
>x2 : X2

declare const arg2: C|B;
>arg2 : B | C

x2.g(x2.f,arg2); // should be no error
>x2.g(x2.f,arg2) : () => "1"
>x2.g : (f: { (x: C): number; (x: B): "1"; }, arg: B | C) => () => "1"
>x2 : X2
>g : (f: { (x: C): number; (x: B): "1"; }, arg: B | C) => () => "1"
>x2.f : { (x: C): number; (x: B): "1"; }
>x2 : X2
>f : { (x: C): number; (x: B): "1"; }
>arg2 : B | C

const x = Math.random() < 0.5 ? x1 : x2;
>x : X1 | X2
>Math.random() < 0.5 ? x1 : x2 : X1 | X2
>Math.random() < 0.5 : boolean
>Math.random() : number
>Math.random : () => number
>Math : Math
>random : () => number
>0.5 : 0.5
>x1 : X1
>x2 : X2

x.g;
>x.g : ((f: { (x: A): string; (x: B): 1; }, arg: A | B) => () => 1) | ((f: { (x: C): number; (x: B): "1"; }, arg: B | C) => () => "1")
>x : X1 | X2
>g : ((f: { (x: A): string; (x: B): 1; }, arg: A | B) => () => 1) | ((f: { (x: C): number; (x: B): "1"; }, arg: B | C) => () => "1")

const arg = Math.random() < 0.5 ? arg1 : arg2;
>arg : A | B | C
>Math.random() < 0.5 ? arg1 : arg2 : A | B | C
>Math.random() < 0.5 : boolean
>Math.random() : number
>Math.random : () => number
>Math : Math
>random : () => number
>0.5 : 0.5
>arg1 : A | B
>arg2 : B | C



type ArgCastType = (A & C) | (A & B) | (B & C);
>ArgCastType : (A & C) | (A & B) | (B & C)


function ftw(x:A):string;
>ftw : { (x: A): string; (x: C): number; (x: B): 1; }
>x : A

function ftw(x:C):number;
>ftw : { (x: A): string; (x: C): number; (x: B): 1; }
>x : C

function ftw(x:B):1;
>ftw : { (x: A): string; (x: C): number; (x: B): 1; }
>x : B

function ftw(x: A|B|C) {
>ftw : { (x: A): string; (x: C): number; (x: B): 1; }
>x : A | B | C

    if ("a" in x) return x.a;
>"a" in x : boolean
>"a" : "a"
>x : A | B | C
>x.a : string
>x : A
>a : string

    if ("c" in x) return x.c;
>"c" in x : boolean
>"c" : "c"
>x : B | C
>x.c : number
>x : C
>c : number

    return 1;
>1 : 1
}

// The necessity of the argument cast is a separate issue!
x.g(ftw,arg as any as any as ArgCastType); // should not be error
>x.g(ftw,arg as any as any as ArgCastType) : (() => 1) | (() => "1")
>x.g : ((f: { (x: A): string; (x: B): 1; }, arg: A | B) => () => 1) | ((f: { (x: C): number; (x: B): "1"; }, arg: B | C) => () => "1")
>x : X1 | X2
>g : ((f: { (x: A): string; (x: B): 1; }, arg: A | B) => () => 1) | ((f: { (x: C): number; (x: B): "1"; }, arg: B | C) => () => "1")
>ftw : { (x: A): string; (x: C): number; (x: B): 1; }
>arg as any as any as ArgCastType : ArgCastType
>arg as any as any : any
>arg as any : any
>arg : A | B | C

function ftx(x:A):string;
>ftx : { (x: A): string; (x: C): number; (x: B): string; }
>x : A

function ftx(x:C):number;
>ftx : { (x: A): string; (x: C): number; (x: B): string; }
>x : C

function ftx(x:B):string; // should cause x.g(ft2) to error
>ftx : { (x: A): string; (x: C): number; (x: B): string; }
>x : B

function ftx(x: A|B|C) {
>ftx : { (x: A): string; (x: C): number; (x: B): string; }
>x : A | B | C

    if ("a" in x) return x.a;
>"a" in x : boolean
>"a" : "a"
>x : A | B | C
>x.a : string
>x : A
>a : string

    if ("c" in x) return x.c;
>"c" in x : boolean
>"c" : "c"
>x : B | C
>x.c : number
>x : C
>c : number

    return x.b;
>x.b : 1
>x : B
>b : 1
}

// The necessity of the argument cast is a separate issue!
x.g(ftx,arg as any as any as ArgCastType); // should be error
>x.g(ftx,arg as any as any as ArgCastType) : (() => 1) | (() => "1")
>x.g : ((f: { (x: A): string; (x: B): 1; }, arg: A | B) => () => 1) | ((f: { (x: C): number; (x: B): "1"; }, arg: B | C) => () => "1")
>x : X1 | X2
>g : ((f: { (x: A): string; (x: B): 1; }, arg: A | B) => () => 1) | ((f: { (x: C): number; (x: B): "1"; }, arg: B | C) => () => "1")
>ftx : { (x: A): string; (x: C): number; (x: B): string; }
>arg as any as any as ArgCastType : ArgCastType
>arg as any as any : any
>arg as any : any
>arg : A | B | C

//function fty(x:A):string;  // should cause x.g(ft2) to error
function fty(x:C):number;
>fty : { (x: C): number; (x: B): 1; }
>x : C

function fty(x:B):1;
>fty : { (x: C): number; (x: B): 1; }
>x : B

function fty(x: {a?: string, c?: number, b?: 1|"1"}) {
>fty : { (x: C): number; (x: B): 1; }
>x : { a?: string | undefined; c?: number | undefined; b?: 1 | "1" | undefined; }
>a : string | undefined
>c : number | undefined
>b : 1 | "1" | undefined

    if (x.a) return x.a;
>x.a : string | undefined
>x : { a?: string | undefined; c?: number | undefined; b?: 1 | "1" | undefined; }
>a : string | undefined
>x.a : string
>x : { a?: string | undefined; c?: number | undefined; b?: 1 | "1" | undefined; }
>a : string

    if (x.c) return x.c;
>x.c : number | undefined
>x : { a?: string | undefined; c?: number | undefined; b?: 1 | "1" | undefined; }
>c : number | undefined
>x.c : number
>x : { a?: string | undefined; c?: number | undefined; b?: 1 | "1" | undefined; }
>c : number

    if (x.b) return x.b;
>x.b : 1 | "1" | undefined
>x : { a?: string | undefined; c?: number | undefined; b?: 1 | "1" | undefined; }
>b : 1 | "1" | undefined
>x.b : 1 | "1"
>x : { a?: string | undefined; c?: number | undefined; b?: 1 | "1" | undefined; }
>b : 1 | "1"

    throw "unexpected error"
>"unexpected error" : "unexpected error"
}

// The necessity of the argument cast is a separate issue!
x.g(fty,arg as any as any as ArgCastType); // should be error
>x.g(fty,arg as any as any as ArgCastType) : (() => 1) | (() => "1")
>x.g : ((f: { (x: A): string; (x: B): 1; }, arg: A | B) => () => 1) | ((f: { (x: C): number; (x: B): "1"; }, arg: B | C) => () => "1")
>x : X1 | X2
>g : ((f: { (x: A): string; (x: B): 1; }, arg: A | B) => () => 1) | ((f: { (x: C): number; (x: B): "1"; }, arg: B | C) => () => "1")
>fty : { (x: C): number; (x: B): 1; }
>arg as any as any as ArgCastType : ArgCastType
>arg as any as any : any
>arg as any : any
>arg : A | B | C

function ftz(x:{a?:string}):string;  // should cause x.g(ft2) to error
>ftz : { (x: {    a?: string;}): string; (x: C): number; (x: B): 1; }
>x : { a?: string | undefined; }
>a : string | undefined

function ftz(x:C):number;
>ftz : { (x: { a?: string | undefined; }): string; (x: C): number; (x: B): 1; }
>x : C

function ftz(x:B):1;
>ftz : { (x: { a?: string | undefined; }): string; (x: C): number; (x: B): 1; }
>x : B

function ftz(x: {a?: string, c?: number, b?: 1|"1"}) {
>ftz : { (x: { a?: string | undefined; }): string; (x: C): number; (x: B): 1; }
>x : { a?: string | undefined; c?: number | undefined; b?: 1 | "1" | undefined; }
>a : string | undefined
>c : number | undefined
>b : 1 | "1" | undefined

    if (x.a) return x.a;
>x.a : string | undefined
>x : { a?: string | undefined; c?: number | undefined; b?: 1 | "1" | undefined; }
>a : string | undefined
>x.a : string
>x : { a?: string | undefined; c?: number | undefined; b?: 1 | "1" | undefined; }
>a : string

    if (x.c) return x.c;
>x.c : number | undefined
>x : { a?: string | undefined; c?: number | undefined; b?: 1 | "1" | undefined; }
>c : number | undefined
>x.c : number
>x : { a?: string | undefined; c?: number | undefined; b?: 1 | "1" | undefined; }
>c : number

    if (x.b) return x.b;
>x.b : 1 | "1" | undefined
>x : { a?: string | undefined; c?: number | undefined; b?: 1 | "1" | undefined; }
>b : 1 | "1" | undefined
>x.b : 1 | "1"
>x : { a?: string | undefined; c?: number | undefined; b?: 1 | "1" | undefined; }
>b : 1 | "1"

    throw "unexpected error"
>"unexpected error" : "unexpected error"
}

// The necessity of the argument cast is a separate issue!
x.g(ftz,arg as any as any as ArgCastType); // should be error
>x.g(ftz,arg as any as any as ArgCastType) : (() => 1) | (() => "1")
>x.g : ((f: { (x: A): string; (x: B): 1; }, arg: A | B) => () => 1) | ((f: { (x: C): number; (x: B): "1"; }, arg: B | C) => () => "1")
>x : X1 | X2
>g : ((f: { (x: A): string; (x: B): 1; }, arg: A | B) => () => 1) | ((f: { (x: C): number; (x: B): "1"; }, arg: B | C) => () => "1")
>ftz : { (x: { a?: string | undefined; }): string; (x: C): number; (x: B): 1; }
>arg as any as any as ArgCastType : ArgCastType
>arg as any as any : any
>arg as any : any
>arg : A | B | C

