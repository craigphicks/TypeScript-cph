//// [tests/cases/compiler/_co/_co-onionOfArrays.ts] ////

=== _co-onionOfArrays.ts ===
declare const arrsn : string[]|number[];
>arrsn : string[] | number[]

declare function strmapol(x:string):string;
>strmapol : { (x: string): string; (x: number): number; }
>x : string

declare function strmapol(x:number):number;
>strmapol : { (x: string): string; (x: number): number; }
>x : number

//declare function strmap(x:number|string):number|string;

// declare function strmapgen<T extends string|number>(x:T):T;

// //type ID = <I>() => (i: I) => I;

// declare const fstrmapgen: <T extends string|number>()=>(x:T)=>T;

// const fstrmapol = ()=>strmapol;




// arrsn.map(strmapgen); // 5.2.2. no error

// arrsn.map(fstrmapgen()); // 5.2.2. error

arrsn.map(strmapol); // 5.2.2 error
>arrsn.map(strmapol) : number[]
>arrsn.map : (<U>(callbackfn: (value: string, index: number, array: string[]) => U, thisArg?: any) => U[]) | (<U_1>(callbackfn: (value: number, index: number, array: number[]) => U_1, thisArg?: any) => U_1[])
>arrsn : string[] | number[]
>map : (<U>(callbackfn: (value: string, index: number, array: string[]) => U, thisArg?: any) => U[]) | (<U_1>(callbackfn: (value: number, index: number, array: number[]) => U_1, thisArg?: any) => U_1[])
>strmapol : { (x: string): string; (x: number): number; }

// arrsn.map(fstrmapol()); // 5.2.2. error
