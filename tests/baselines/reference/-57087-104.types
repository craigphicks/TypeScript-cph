//// [tests/cases/compiler/-test3/-57087-104.ts] ////

=== -57087-104.ts ===
interface C {
  (x:1):"1";
>x : 1

  (x:2):"20";
>x : 2

  (x:number):number | "1" | "20";
>x : number

};
interface B {
  (x:2):"2"
>x : 2

  (x:3):"30"
>x : 3

  (x:number):number | "2" | "30";
>x : number

};
interface A {
  (x:3):"3"
>x : 3

  (x:1):"10"
>x : 1

  (x:number):number | "3" | "10";
>x : number

};

type W = (A & B & C)|(A & C & B)|(B & A & C)|(B & C & A)|(C & A & B)|(C & B & A);
>W : (A & B & C) | (A & C & B) | (B & A & C) | (B & C & A) | (C & A & B) | (C & B & A)

/*
* Scenario:
* (1) Overloads: Usng fully expanded domain support for C & B & A, so that all errors are detected at compile time
* (2) Implementation:
*     - Note extra lines added to make the function signature compatible with the implementation
* Disadvatage: More verbosity in number of overloads and in implementation.
* Number of overloads could impact compile time, and makes life harder for downstream users of the function
*/
function foo2(x:1):"1";
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>x : 1

function foo2(x:2):"20";
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>x : 2

function foo2(x:number):number;
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>x : number

function foo2(x:2):"2"
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>x : 2

function foo2(x:3):"30"
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>x : 3

function foo2(x:number):number;
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>x : number

function foo2(x:3):"3"
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>x : 3

function foo2(x:1):"10"
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>x : 1

function foo2(x:number):number;
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>x : number

function foo2(x:number){
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>x : number

  if (x===1) return "1";
>x===1 : boolean
>x : number
>1 : 1
>"1" : "1"

  if (x===2) return "2";
>x===2 : boolean
>x : number
>2 : 2
>"2" : "2"

  if (x===3) return "3";
>x===3 : boolean
>x : number
>3 : 3
>"3" : "3"

  // (*) These nonsense unused extra lines need to be added to make the function signature compatible with the implementation
  if (x===1) return "10";
>x===1 : boolean
>x : number
>1 : 1
>"10" : "10"

  if (x===2) return "20";
>x===2 : boolean
>x : number
>2 : 2
>"20" : "20"

  if (x===3) return "30";
>x===3 : boolean
>x : number
>3 : 3
>"30" : "30"

  return x;
>x : number
}

foo2 satisfies A & B & C; // should satisfy
>foo2 satisfies A & B & C : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }

foo2 satisfies A & C & B; // should satisfy
>foo2 satisfies A & C & B : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }

foo2 satisfies B & A & C; // should satisfy
>foo2 satisfies B & A & C : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }

foo2 satisfies B & C & A; // should satisfy
>foo2 satisfies B & C & A : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }

foo2 satisfies C & A & B; // should satisfy
>foo2 satisfies C & A & B : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }

foo2 satisfies C & B & A; // should satisfy
>foo2 satisfies C & B & A : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }

foo2 satisfies W; // should satisfy
>foo2 satisfies W : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }
>foo2 : { (x: 1): "1"; (x: 2): "20"; (x: number): number; (x: 2): "2"; (x: 3): "30"; (x: number): number; (x: 3): "3"; (x: 1): "10"; (x: number): number; }


/*
* Scenario: Select some overloads from the orignal set of overloads.
* Advantages:
*     - Less verbosity in number of overloads
*     - Less verbosity in implementation
* Number of overloads could impact compile time, and makes life harder for downstream users of the function
*/
function foo1(x:1):"1";
>foo1 : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>x : 1

function foo1(x:2):"2";
>foo1 : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>x : 2

function foo1(x:3):"3";
>foo1 : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>x : 3

function foo1(x:number):number;
>foo1 : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>x : number

function foo1(x:number){
>foo1 : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>x : number

  if (x===1) return "1";
>x===1 : boolean
>x : number
>1 : 1
>"1" : "1"

  if (x===2) return "2";
>x===2 : boolean
>x : number
>2 : 2
>"2" : "2"

  if (x===3) return "3";
>x===3 : boolean
>x : number
>3 : 3
>"3" : "3"

  return x;
>x : number
}

// The `&`-intersection operator result should be independent of the order of it's operands.
foo1 satisfies A & B & C; // should not error
>foo1 satisfies A & B & C : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>foo1 : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }

foo1 satisfies A & C & B; // should not error
>foo1 satisfies A & C & B : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>foo1 : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }

foo1 satisfies B & A & C; // should not error
>foo1 satisfies B & A & C : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>foo1 : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }

foo1 satisfies B & C & A; // should not error
>foo1 satisfies B & C & A : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>foo1 : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }

foo1 satisfies C & A & B; // should not error
>foo1 satisfies C & A & B : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>foo1 : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }

foo1 satisfies C & B & A; // should not error
>foo1 satisfies C & B & A : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>foo1 : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }

foo1 satisfies W; // should not error
>foo1 satisfies W : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>foo1 : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number; }

/*
*/

//function foo3(x:1):"1"; //  Omitted domain support should cause satisfies error
function foo3(x:2):"2";
>foo3 : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>x : 2

function foo3(x:3):"3";
>foo3 : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>x : 3

function foo3(x:number):number;
>foo3 : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>x : number

function foo3(x:number): number | "1" | "2" | "3"{
>foo3 : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>x : number

  //if (x===1) return "1";
  if (x===2) return "2";
>x===2 : boolean
>x : number
>2 : 2
>"2" : "2"

  if (x===3) return "3";
>x===3 : boolean
>x : number
>3 : 3
>"3" : "3"

  return x;
>x : number

  // In this case, a final throw "unexpected error" would never be reached anyway.
  // if (typeof x === "number") return x; // pointless
  // throw "unexpected error";
}

foo3 satisfies A & B & C; // should be error
>foo3 satisfies A & B & C : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>foo3 : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }

foo3 satisfies A & C & B; // should be error
>foo3 satisfies A & C & B : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>foo3 : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }

foo3 satisfies B & A & C; // should be error
>foo3 satisfies B & A & C : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>foo3 : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }

foo3 satisfies B & C & A; // should be error
>foo3 satisfies B & C & A : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>foo3 : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }

foo3 satisfies C & A & B; // should be error
>foo3 satisfies C & A & B : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>foo3 : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }

foo3 satisfies C & B & A; // should be error
>foo3 satisfies C & B & A : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>foo3 : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }


foo3 satisfies W; // should be error
>foo3 satisfies W : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }
>foo3 : { (x: 2): "2"; (x: 3): "3"; (x: number): number; }


