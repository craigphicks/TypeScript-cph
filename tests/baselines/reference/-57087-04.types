//// [tests/cases/compiler/-test/-57087-04.ts] ////

=== -57087-04.ts ===
interface C {
  (x:1):"1";
>x : 1

  (x:2):"20";
>x : 2

  (x:number):number | "1" | "20";
>x : number

};
interface B {
  (x:2):"2"
>x : 2

  (x:3):"30"
>x : 3

  (x:number):number | "2" | "30";
>x : number

};
interface A {
  (x:3):"3"
>x : 3

  (x:1):"10"
>x : 1

  (x:number):number | "3" | "10";
>x : number

};

  function foo(x:1):"1";
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>x : 1

  function foo(x:2):"2";
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>x : 2

  function foo(x:3):"3";
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>x : 3

  function foo(x:number):number|"1"|"2"|"3";
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>x : number

  function foo(x:number):number|"1"|"2"|"3"{
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>x : number

    if (x==1||x==2||x==3) return String(x) as any;
>x==1||x==2||x==3 : boolean
>x==1||x==2 : boolean
>x==1 : boolean
>x : number
>1 : 1
>x==2 : boolean
>x : number
>2 : 2
>x==3 : boolean
>x : number
>3 : 3
>String(x) as any : any
>String(x) : string
>String : StringConstructor
>x : 1 | 2 | 3

    return x;
>x : number
  }

  // The `&`-intersection operator result should be independent of the order of it's operands.
  foo satisfies A & B & C;
>foo satisfies A & B & C : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }

  foo satisfies A & C & B;
>foo satisfies A & C & B : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }

  foo satisfies B & A & C;
>foo satisfies B & A & C : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }

  foo satisfies B & C & A;
>foo satisfies B & C & A : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }

  foo satisfies C & A & B;
>foo satisfies C & A & B : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }

  foo satisfies C & B & A;
>foo satisfies C & B & A : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }

  type W = (A & B & C)|(A & C & B)|(B & A & C)|(B & C & A)|(C & A & B)|(C & B & A);
>W : (A & B & C) | (A & C & B) | (B & A & C) | (B & C & A) | (C & A & B) | (C & B & A)

  declare const w:W;
>w : W

  w(1);// "1","10"
>w(1) : "1" | "10"
>w : W
>1 : 1

  w(2);// "2","20"
>w(2) : "20" | "2"
>w : W
>2 : 2

  w(3);// "3","30"
>w(3) : "30" | "3"
>w : W
>3 : 3

  foo(1); // "1"
>foo(1) : "1"
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>1 : 1

  foo(2); // "2"
>foo(2) : "2"
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>2 : 2

  foo(3); // "3"
>foo(3) : "3"
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>3 : 3

  foo satisfies W;
>foo satisfies W : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }
>foo : { (x: 1): "1"; (x: 2): "2"; (x: 3): "3"; (x: number): number | "1" | "2" | "3"; }

