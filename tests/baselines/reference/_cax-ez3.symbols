=== tests/cases/conformance/_cax/_cax-ez3.ts ===
declare type Foo = { 
>Foo : Symbol(Foo, Decl(_cax-ez3.ts, 0, 0))

    foo(x?:number):number[] 
>foo : Symbol(foo, Decl(_cax-ez3.ts, 0, 20), Decl(_cax-ez3.ts, 1, 27))
>x : Symbol(x, Decl(_cax-ez3.ts, 1, 8))

    foo(x?:string,y?:string):string[] 
>foo : Symbol(foo, Decl(_cax-ez3.ts, 0, 20), Decl(_cax-ez3.ts, 1, 27))
>x : Symbol(x, Decl(_cax-ez3.ts, 2, 8))
>y : Symbol(y, Decl(_cax-ez3.ts, 2, 18))

};
declare type Boo = { 
>Boo : Symbol(Boo, Decl(_cax-ez3.ts, 3, 2))

    foo(x?:bigint):bigint[]  
>foo : Symbol(foo, Decl(_cax-ez3.ts, 4, 20))
>x : Symbol(x, Decl(_cax-ez3.ts, 5, 8))

};
declare const obj: Readonly<Foo> | Readonly<Boo> | undefined;
>obj : Symbol(obj, Decl(_cax-ez3.ts, 7, 13))
>Readonly : Symbol(Readonly, Decl(lib.es5.d.ts, --, --))
>Foo : Symbol(Foo, Decl(_cax-ez3.ts, 0, 0))
>Readonly : Symbol(Readonly, Decl(lib.es5.d.ts, --, --))
>Boo : Symbol(Boo, Decl(_cax-ez3.ts, 3, 2))

// declare const okobj: Readonly<Foo> | Readonly<Boo>;
const isFoo = obj?.foo();
>isFoo : Symbol(isFoo, Decl(_cax-ez3.ts, 9, 5))
>obj?.foo : Symbol(foo, Decl(_cax-ez3.ts, 0, 20), Decl(_cax-ez3.ts, 1, 27), Decl(_cax-ez3.ts, 4, 20))
>obj : Symbol(obj, Decl(_cax-ez3.ts, 7, 13))
>foo : Symbol(foo, Decl(_cax-ez3.ts, 0, 20), Decl(_cax-ez3.ts, 1, 27), Decl(_cax-ez3.ts, 4, 20))

//let x: Readonly<Foo> | Readonly<Boo> | undefined;
if (isFoo) {
>isFoo : Symbol(isFoo, Decl(_cax-ez3.ts, 9, 5))

    isFoo;
>isFoo : Symbol(isFoo, Decl(_cax-ez3.ts, 9, 5))

    let x = obj; // x should be Readonly<Foo> | Readonly<Boo>
>x : Symbol(x, Decl(_cax-ez3.ts, 13, 7))
>obj : Symbol(obj, Decl(_cax-ez3.ts, 7, 13))

    let y = x.foo; // should be no error
>y : Symbol(y, Decl(_cax-ez3.ts, 14, 7))
>x.foo : Symbol(foo, Decl(_cax-ez3.ts, 0, 20), Decl(_cax-ez3.ts, 1, 27), Decl(_cax-ez3.ts, 4, 20))
>x : Symbol(x, Decl(_cax-ez3.ts, 13, 7))
>foo : Symbol(foo, Decl(_cax-ez3.ts, 0, 20), Decl(_cax-ez3.ts, 1, 27), Decl(_cax-ez3.ts, 4, 20))

    let z = y(); // z should be number[] | string[] | bigint[] - it is not because obtained via checker.ts,resolveCallExpression
>z : Symbol(z, Decl(_cax-ez3.ts, 15, 7))
>y : Symbol(y, Decl(_cax-ez3.ts, 14, 7))

    console.log(z); // again z should be number[] | string[] | bigint[] - now it is because it is obtained via getFlowTypeOfReference
>console.log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>console : Symbol(console, Decl(lib.dom.d.ts, --, --))
>log : Symbol(Console.log, Decl(lib.dom.d.ts, --, --))
>z : Symbol(z, Decl(_cax-ez3.ts, 15, 7))
} 
isFoo;
>isFoo : Symbol(isFoo, Decl(_cax-ez3.ts, 9, 5))

