=== tests/cases/conformance/_cax/_cax-enum-0001.ts ===
declare const enum E {
>E : Symbol(E, Decl(_cax-enum-0001.ts, 0, 0))

    n1 = 1,
>n1 : Symbol(E.n1, Decl(_cax-enum-0001.ts, 0, 22))

    n2 = 2,
>n2 : Symbol(E.n2, Decl(_cax-enum-0001.ts, 1, 11))

    sa = "a",
>sa : Symbol(E.sa, Decl(_cax-enum-0001.ts, 2, 11))

    sb = "b"
>sb : Symbol(E.sb, Decl(_cax-enum-0001.ts, 3, 13))

};
declare const enum F {
>F : Symbol(F, Decl(_cax-enum-0001.ts, 5, 2))

    n1 = 1,
>n1 : Symbol(F.n1, Decl(_cax-enum-0001.ts, 6, 22))

    n2 = 2,
>n2 : Symbol(F.n2, Decl(_cax-enum-0001.ts, 7, 11))

    sa = "a",
>sa : Symbol(F.sa, Decl(_cax-enum-0001.ts, 8, 11))

    sb = "b"
>sb : Symbol(F.sb, Decl(_cax-enum-0001.ts, 9, 13))

};

declare const e: E|F;
>e : Symbol(e, Decl(_cax-enum-0001.ts, 13, 13))
>E : Symbol(E, Decl(_cax-enum-0001.ts, 0, 0))
>F : Symbol(F, Decl(_cax-enum-0001.ts, 5, 2))

// The "else" clause has an impossible inference.
// Therefore, it would be proper to evaluate the "if" clause using the literal "1" on the rhs,
// ignoring the leading "E", and not narrowing e to type E, but leaving it as E|F.

if (e===E.n1){
>e : Symbol(e, Decl(_cax-enum-0001.ts, 13, 13))
>E.n1 : Symbol(E.n1, Decl(_cax-enum-0001.ts, 0, 22))
>E : Symbol(E, Decl(_cax-enum-0001.ts, 0, 0))
>n1 : Symbol(E.n1, Decl(_cax-enum-0001.ts, 0, 22))

    e; // E.n1
>e : Symbol(e, Decl(_cax-enum-0001.ts, 13, 13))
}
// @ts-ignore to suppress TS2367
else if (e===1){
>e : Symbol(e, Decl(_cax-enum-0001.ts, 13, 13))

    // Compile error TS2367 doesn't show up in the GUI, only compile time
    // Error TS2367: This condition will always return 'false' since the types '2 | "a" | "b"' and '1' have no overlap.
    e; // F.n1 !!!! This makes no "runtime" sense. Should be never.
>e : Symbol(e, Decl(_cax-enum-0001.ts, 13, 13))
}



