Fixes #50377 - allowing `Boolean` as a predicate to Array.filter with falsey types filtered in the result.
Fixes #56013 (*) - Adding an overload to .filter breaks specific inference with nested functions
(* with qualification: The original #56013 added the filter overload externally.  The bug is only fixed for the case where the overload is added internally, as it is in this pull).

## Source Files changed:

- `src/lib/es5.d.ts`
- `src/compiler/checker.ts`

## Added Test Files

- tests/cases/compiler/arrayFilterBooleanOverload#56013WithoutExternalOverload.ts
- tests/cases/compiler/arrayFilterBooleanOverload.ts
- tests/cases/compiler/unionOfArraysBooleanFilterCall.ts
- tests/cases/compiler/arrayMapPredicates1.ts

This one was not added by this pull, but is related:
- tests/cases/fourslash/completionEntryForUnionMethod.ts


## Related issues

filter(Boolean)
#50377 Explore adding the Boolean to filter to narrow out null/undefined in array#filter (closed pull)
#50387 Add BooleanConstructor as an overload to .filter to allow for easy type predicate filtering (inDiscussion)
#30621 narrow array type with .filter(Boolean) (marked as duplicate of #16655, although #16655 is more broad than #30621)
#56013 Adding an overload to .filter breaks specific inference with nested functions (related)
#55777

Boolean as falsey check in general
#16655 Boolean() cannot be used to perform a null check (broader than filter(Boolean))
#29955 Allow Boolean() to be used to perform a null check (accepted pull, may have reverted)

#53489 Add fallback logic for generating signatures for unions of array members

## Source code changes

- `es5.d.ts`: Overload for filter with Boolean predicate is added for both [Array](https://github.com/microsoft/TypeScript/pull/56281/files?file-filters%5B%5D=.ts&show-viewed-files=false#r1382349785) and [ReadonlyArray](https://github.com/microsoft/TypeScript/pull/56281/files?file-filters%5B%5D=.ts&show-viewed-files=false#r1382349772).

- `checker.ts`
    - With new filter overloads, `getSignaturesOfStructuredType()` returns an invalid result of length 1.  The strategy to address that is to piggyback onto #53489.
    - #53489 used a carveout which included a condition that `getSignaturesOfStructuredType()` return a result of length 0.
    - In the interests of generality, [the length condition is dropped altogether](https://github.com/microsoft/TypeScript/pull/56281/files?file-filters%5B%5D=.ts&show-viewed-files=false#r1382421482), rather than just length <= 1, and includes all array methods.
    - The original #53489 carveout logic was "*Transform the type from `(A[] | B[])["member"]` to `(A | B)[]["member"]` (since we pretend array is covariant anyway)*".  This pull modifies some method return types to be a union of the return types of the members, e.g., `ReturnType<(A[])["member"]> | ReturnType<(B[])["member"]>` instead of  `ReturnType<(A|B)["member"]>`, but only in cases where the return type does not have a type parameter.  This change was in response to [this reviewer comment](https://github.com/microsoft/TypeScript/pull/56281#discussion_r1378804648). *(The parameters remain unchanged.)*


## Regressions

1. `Array<string>.map` completion is [changed](https://github.com/microsoft/TypeScript/pull/56281/files?file-filters%5B%5D=.ts&show-viewed-files=false#r1382324409) from
```
(method) Array<T>.map<unknown>(callbackfn: ((value: string, index: number, array: string[]) => unknown) & ((value: number, index: number, array: number[]) => unknown), thisArg?: any): unknown[]
```
to
```
"(method) Array<T>.map<unknown>(callbackfn: (value: string | number, index: number, array: (string | number)[]) => unknown, thisArg?: any): unknown[]"
```

2. `Array<string|number>.map(((value: string, index: number, array: string[]) => unknown) & ((value: number, index: number, array: number[]) => unknown))` is now an [error](https://github.com/microsoft/TypeScript/pull/56281/commits/e904d7772b0990a6169e3c1f8a876e9bcabcc8f0#r1382389001). (Intersection of functions predicate type.) It was previously not an error.

3. `Array<string|number>.map({((value: string, index: number, array: string[]) => unknown), ((value: number, index: number, array: number[]) => unknown)})` is now [error](). (Overload function predicate type.) It was previously not an error.

It could be argued these regressions, occuring only in the rare case where the return is of type `unknown`, are not a serious problem.
Arguable there are benefits to the new completion shown in 1.  A listing of `arrayMapPredicates1` is shown below.

```
type ArrayPredISect<S,N> = ((value: string, index: number, array: string[]) => S) & ((value: number, index: number, array: number[]) => N)

interface ArrayPredOverload <S,N> {
    (value: string, index: number, array: string[]): S,
    (value: number, index: number, array: number[]): N
}

type ArrayPredUnion<S,N> = ((value: string|number, index: number, array: (string|number)[]) => S | N)


declare const pisect1:ArrayPredISect<string,number>
declare const pisect2:ArrayPredISect<unknown,unknown>

declare const poload1:ArrayPredOverload<string,number>
declare const poload2:ArrayPredOverload<unknown,unknown>

declare const punion1:ArrayPredUnion<string,number>
declare const punion2:ArrayPredUnion<unknown,unknown>


declare const asn: string[]|number[];
asn.map(pisect1); // 5.2.2. & #56821 error
asn.map(pisect2); // #56821 error only

asn.map(poload1); // 5.2.2.  & #56821 error
asn.map(poload2); // #56821 error only.

asn.map(punion1);
asn.map(punion2);

declare const asun: (string|number)[];

asun.map(pisect1); // 5.2.2. & #56821 error
asun.map(pisect2); // 5.2.2. & #56821 error

asun.map(poload1); // 5.2.2. & #56821 error
asun.map(poload2); // 5.2.2. & #56821 error

asun.map(punion1);
asun.map(punion2);

declare const astr: string[];
astr.map(pisect1); // 5.2.2.  & #56821 error
astr.map(pisect2);

astr.map(poload1); // 5.2.2.  & #56821 error
astr.map(poload2);

astr.map(punion1);
astr.map(punion2);
```
Here the are the different kinds of Arrays: `Array<string[]|number[]>`, `Array<(string|number)[]>`, `Array<string[]>`,
being tested with two variations each of three different predicate types: `ArrayPredISect`, `ArrayPredOverload`, `ArrayPredUnion`.
The variations are predicate return types of `string`/`number` and `unknown`.

What is noticable is that:
- the errors should not be there.
- only `ArrayPredUnion` predicate type has no errors in all of its 6 combinations.

That implies that a user who is using `ArrayPredUnion` is not likely to encounter any frustrating errors,
and therefore that regression 1 listed above, offering the union predicate completion, is actually a benefit.

## Criticism

- 1. It could be argued that the scope of the changes in this pull go to far beyond filter Boolean overload in the title, and it has become an omnibus pull.
- 2. Going in the other direction,
it could be argued that the scope of the changes in this pull do not go far enough, are just a patch on a patch, and the real problem
lies in the contorted workarounds to pre process the candidates before they enter `chooseOverload`.  The real solution would be
to have `chooseOverload` be able to handle the candidates as they are, without preprocessing, in an efficient way.

Both could be true.

Regarding 1, it would be simple to limit the scope of the changes to just the filter Boolean overload.

Regarding 2, here is an outline of a possible algorithm for processing generics in `chooseOverload`:

